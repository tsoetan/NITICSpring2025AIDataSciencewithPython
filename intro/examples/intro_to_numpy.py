# -*- coding: utf-8 -*-
"""AIPy 1 D - NumPy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HzKXVl2VvzS31OPFAQ9x9t7f_NHDy-zF

# NumPy

## Creating Arrays
"""

import numpy as np

# From Python lists
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([[1, 2, 3], [4, 5, 6]])

# Using NumPy functions
zeros = np.zeros((3, 4))      # 3x4 array of zeros
ones = np.ones((2, 3))        # 2x3 array of ones
random = np.random.rand(2, 2)  # 2x2 array of random numbers

print(arr1)
print(arr2)
print(zeros)
print(ones)
print(random)

"""## Array Properties & Attributes"""

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.shape)    # (2, 3) - dimensions
print(arr.ndim)     # 2 - number of dimensions
print(arr.dtype)    # int64 - data type
print(arr.size)     # 6 - total number of elements

"""## Array Operations: Element-wise"""

# Basic arithmetic
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

print(arr1 + arr2)  # [5, 7, 9]
print(arr1 * arr2)  # [4, 10, 18]
print(arr1 ** 2)    # [1, 4, 9]

# Comparison operations
print(arr1 > 2)     # [False, False, True]

"""## Broadcasting allows NumPy to work with arrays of different shapes"""

# Broadcasting example
matrix = np.array([[1, 2, 3],
                   [4, 5, 6]])
vector = np.array([1, 0, 1])

# Broadcasting the vector across each row
print(matrix + vector)  # [[2, 2, 4],
                        #  [5, 5, 7]]

"""## Array Operations: Indexing & Slicing"""

arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

print(arr[0])       # First row: [1, 2, 3]
print(arr[:, 1])    # Second column: [2, 5, 8]
print(arr[1:3, 1:]) # 2x2 slice: [[5, 6],
                    #             [8, 9]]

"""## Array Manipulation"""

# Reshaping
arr = np.array([1, 2, 3, 4, 5, 6])
print(arr.reshape(2, 3))  # [[1, 2, 3],
                          #  [4, 5, 6]]

# Concatenation
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
print(np.concatenate([arr1, arr2]))  # [1, 2, 3, 4, 5, 6]

"""## Matrix Operations


"""

A = np.random.rand(3,4)
B = np.random.rand(4,3)
C = np.random.rand(3,4)

# Scalar Multiplication
product = 2 * A
print(product)

# Matrix Multiplication
product = np.matmul(A,B)
print(product)

# Element-wise Multiplication
product = np.multiply(A,C)
print(product)

# Dot Product (common in neural networks)
weights = np.random.rand(3, 4)
inputs = np.random.rand(4, 5)
layer_output = np.dot(weights, inputs)
print(layer_output)

# Computing distances (common in clustering)
point1 = np.array([1, 2])
point2 = np.array([4, 6])
distance = np.sqrt(np.sum((point1 - point2) ** 2))
print(f"The distance between {point1} and {point2} is {distance}")

"""## Data Preprocessing"""

# Standardization
data = np.array([1, 2, 3, 4, 5])
mean = np.mean(data)
std = np.std(data)
standardized = (data - mean) / std
print(standardized)

# One-hot encoding
categories = np.array([0, 1, 2, 1, 0])
one_hot = np.eye(3)[categories]
print(one_hot)

"""## Best Practices: Avoid Loops

"""

loop_arr = np.empty(len(arr))

# Bad (slow):
for i in range(len(arr)):
    loop_arr[i] = arr[i] * 2
print(loop_arr)

# Good (fast):
arr = arr * 2
print(arr)

"""## Best Practices: Use Appropriate Data Type"""

# If you know your data is integers 0-255:
short_arr = np.array([1, 2, 3], dtype=np.uint8)
print(short_arr)